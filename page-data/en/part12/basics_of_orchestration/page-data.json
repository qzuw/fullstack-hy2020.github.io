{"componentChunkName":"component---src-templates-content-template-js","path":"/en/part12/basics_of_orchestration","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h3>React</h3>\n<p>Let's create and containerize a react application next. I'll choose npm as the package manager even though create-react-app defaults to yarn.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npx create-react-app hello-front --use-npm\n  ...\n\n  Happy hacking!</code></pre></div>\n<p>The create-react-app already installed all dependencies for us, so we did not need to run npm install here.</p>\n<p>The next step is to turn the code, js and modules, into production-ready static files. Create-react-app already has build as an npm script so let's use that:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm run build\n  ...\n\n  Creating an optimized production build...\n  ...\n  The build folder is ready to be deployed.\n  ...</code></pre></div>\n<p>Great! Final step is figuring a way to use a server to serve the static files. As you may know we could use our <a href=\"https://expressjs.com/en/starter/static-files.html\">express.static</a> with the express server to serve static files. I'll leave that as an exercise, instead we are going to go ahead and start writing our Dockerfile.</p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>16\n\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">RUN</span> npm run build</code></pre></div>\n<p>That looks about right, let's build it and see if we are on the right track, our goal is to have the build succeed without errors. Then we will use bash to check inside of the container to see if the files are there.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker build . -t hello-front\n  [+] Building 172.4s (10/10) FINISHED \n\n$ docker run -it hello-front bash\n\nroot@98fa9483ee85:/usr/src/app# ls\n  Dockerfile  README.md  build  node_modules  package-lock.json  package.json  public  src\n\nroot@98fa9483ee85:/usr/src/app# ls build/\n  asset-manifest.json  favicon.ico  index.html  logo192.png  logo512.png  manifest.json  robots.txt  static</code></pre></div>\n<p>A valid option for serving static files now that we already have node in the container is <a href=\"https://www.npmjs.com/package/serve\">serve</a>. Let's try installing serve and serving the static files while we are inside the container.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@98fa9483ee85:/usr/src/app# npm install -g serve\n\n  added 88 packages, and audited 89 packages in 6s\n\nroot@98fa9483ee85:/usr/src/app# serve build\n\n   ┌───────────────────────────────────┐\n   │                                   │\n   │   Serving!                        │\n   │                                   │\n   │   Local:  http://localhost:5000   │\n   │                                   │\n   └───────────────────────────────────┘</code></pre></div>\n<p>Great! Let's ctrl+c and exit out and then add those to our Dockerfile.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  ^C\n  INFO: Gracefully shutting down. Please wait...\n\nroot@98fa9483ee85:/usr/src/app# exit\n  exit</code></pre></div>\n<p>The installation of serve turns into a RUN so that the dependency is installed during the build process. And the command to serve build directory will be the command to start the software with.</p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token punctuation\">...</span>\n<span class=\"token keyword\">RUN</span> npm install <span class=\"token punctuation\">-</span>g serve\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"serve\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"build\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>And then build <em>docker build -t hello-front .</em> and run it <em>docker run -p 5000:5000 hello-front</em>. The app will then be available in <a href=\"http://localhost:5000\">http://localhost:5000</a>.</p>\n<h3>Using multiple stages</h3>\n<p>While serve is a <i>valid</i> option we can do better. With containers a good goal is to create the containers so that they do not contain anything irrelevant so that they have a small number of dependencies and are less likely to break or become vulnerable over time. </p>\n<p>Multi-stage builds are designed for splitting the build process into multiple stages. Conventional options for stages are build stage and test stage. The main goal for using stages is to limit the size of the image. Smaller images are faster to upload and download and they help reduce the number of vulnerabilities your software may have.</p>\n<p>With multi-stage builds a tried and true solution like <a href=\"https://en.wikipedia.org/wiki/Nginx\">nginx</a>, can be used to serve static files without a lot of headache. The docker hub <a href=\"https://hub.docker.com/_/nginx\">page for nginx</a> tells us the required info to open the ports and \"Hosting some simple static content\".</p>\n<p>Let's use the previous Dockerfile but change the FROM to include the name of the stage:</p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># The first FROM is now a stage called build-stage</span>\n<span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>16 AS build<span class=\"token punctuation\">-</span>stage\n\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">RUN</span> npm run build\n\n<span class=\"token comment\"># This is a new stage, everything before this is gone, except the files we want to COPY</span>\n<span class=\"token keyword\">FROM</span> nginx<span class=\"token punctuation\">:</span>1.20<span class=\"token punctuation\">-</span>alpine\n\n<span class=\"token comment\"># COPY the directory build from build-stage to /usr/share/nginx/html</span>\n<span class=\"token comment\"># The target location here was found from the docker hub page</span>\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=build<span class=\"token punctuation\">-</span>stage /usr/src/app/build /usr/share/nginx/html</code></pre></div>\n<p>Now we have declared the build stage and only move the relevant files, the build directory with static content, into an image that is ready to serve the static content.</p>\n<p>The default port will be 80 for nginx, so something like <em>-p 8000:80</em> will work.</p>\n<p>Multi-stage builds also include some internal optimizations that may affect your builds. As an example, multi-stage builds skip stages that are not used. If we wish to use a stage to replace a part of a build pipeline, like testing or notifications, we must pass <strong>some</strong> data to the following stages. In some cases this is justified: copy the code from testing stage to build stage ensuring that you are building the tested code.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercises 12.13 - 12.14.</h3>\n<h4>Exercise 12.13: Todo application frontend</h4>\n<blockquote>\n<p>In this exercise, submit <i>at least</i> the Dockerfile you created.</p>\n</blockquote>\n<p>The following repository contains an react application in the react-app directory. </p>\n<p><a href=\"https://github.com/fullstack-hy2020/part12-containers-applications/tree/main/react-app\">https://github.com/fullstack-hy2020/part12-containers-applications/tree/main/react-app</a></p>\n<p>Copy the contents into your own repository. The react-app directory includes a README on how to start the application.</p>\n<p>Containerize the application and use <a href=\"https://docs.docker.com/engine/reference/builder/#env\">ENV</a> instruction to pass <em>REACT_APP_BACKEND_URL</em> to the application and run it with the backend. Backend can be running outside a container.</p>\n<h4>Exercise 12.14: Testing during build process</h4>\n<blockquote>\n<p>In this exercise, submit the entire React application, with the Dockerfile.</p>\n</blockquote>\n<p>We can use multiple stages to do testing during the build process. The build process will fail as the tests fail.</p>\n<p>Extract a component <code class=\"language-text\">Todo</code> that represents a single todo. Write a test for the new component add run it the build process. You can add a new stage for the test if you wish to do so.</p>\n</div>\n<div class=\"content\">\n<h3>Developing in containers</h3>\n<p>Let's move the todo application development to a container. There are a few reasons why you would want to do that:</p>\n<ol>\n<li>To keep the environment similar between development and production to avoid bugs that appear only in production environment</li>\n<li>To avoid differences between developers and their own environments that lead difficulties in application development</li>\n<li>To help new team members hop in by having them only be required to install container runtime</li>\n</ol>\n<p>These are great reasons. The tradeoff is that we may encounter some unconventional behavior when we aren't running the applications like we are used to. We will need to do at least two things to move the application to a container:</p>\n<ol>\n<li>Start the application in development mode</li>\n<li>Access the files with vscode</li>\n</ol>\n<p>And let's start with the frontend. Since the Dockerfile will be significantly different to the production Dockerfile let's create a new one called <em>dev.Dockerfile</em>. Let's just place this new file in the root of the project.</p>\n<p>Starting the create-react-app in development mode should be easy, lets start with the following:</p>\n<p><code class=\"language-text\">dev.Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>16\n\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token comment\"># Change npm ci to npm install since we are going to be in development mode</span>\n<span class=\"token keyword\">RUN</span> npm install\n\n<span class=\"token comment\"># npm start is the command to start the application in development mode</span>\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"npm\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"start\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>During build the flag <em>-f</em> will be used to tell which file to use, it would otherwise default to Dockerfile, so <em>docker build -f ./dev.Dockerfile -t hello-front-dev .</em> will build the image. The create-react-app will be served in port 3000, so you can test that it works by running a container with that port published.</p>\n<p>The second task, accessing the files with vscode, is not done yet. There are at least two ways of doing this: </p>\n<ol>\n<li><a href=\"https://code.visualstudio.com/docs/remote/containers\">The Visual Studio Code Remote - Containers extension</a> </li>\n<li>Volumes, the same thing we used to preserve data with the database</li>\n</ol>\n<p>Let's go over the latter since that will work with other editors as well. Let's do a trial run with the flag <em>-v</em> and if that works then we will move the configuration to a docker-compose file. To use the <em>-v</em> we will need to tell it the current directory. The command <em>pwd</em> should output the path to the current directory for you. Try this with <em>echo $(pwd)</em> in your command line. We can use that as the left side for <em>-v</em> to map current directory to the inside of the container or you can use the full directory path.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker run -p 3000:3000 -v &quot;$(pwd):/usr/src/app/&quot; hello-front-dev\n\n  Compiled successfully!\n\n  You can now view hello-front in the browser.</code></pre></div>\n<p>Now we can simply edit the src/App.js and the changes should be hot-loaded to the browser.</p>\n<p>Next let's move that config to a docker-compose.yml. That file should be at the root of the project as well.</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> . <span class=\"token comment\"># The context will pick this directory as the \"build context\"</span>\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile <span class=\"token comment\"># This will simply tell which dockerfile to read</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app <span class=\"token comment\"># The path can be relative, so ./ is enough to say \"the same location as the docker-compose.yml\"</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 3000<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev <span class=\"token comment\"># This will name the container hello-front-dev</span></code></pre></div>\n<p>With this <em>docker-compose up</em> can run the application in development mode. You don't even need node installed to develop it!</p>\n<p>Installing new dependencies is a headache for a development setup like this. One of the better options is to install the new dependency <strong>inside</strong> the container. So instead of doing e.g. <em>npm install axios</em>, you have to do it in the running container e.g. <em>docker exec hello-front-dev npm install axios</em>. Or add it to the package.json and run <em>docker build</em> again.</p>\n<h3>Communication between containers in a docker network</h3>\n<p>The docker-compose tool sets up a network between the containers and includes a DNS to easily connect two containers to one another. Let's add a new service to the docker-compose and we can see how the network and DNS work.</p>\n<p><i>Busybox</i> is a small executable with multiple tools you may need. It is called \"The Swiss Army Knife of Embedded Linux\" and we definitely can use it to our advantage.</p>\n<p>It can be used to debug our configurations. So if you get lost in the later exercises of this section you should use BusyBox to find out what works and what doesn't. Let's use it to explore what I just said. That containers are inside a network and you can easily connect between them.</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 3000<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n\n  <span class=\"token key atrule\">debug-helper</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox</code></pre></div>\n<p>The busybox won't have any process running inside so that we could exec in there. Because of that the output of <em>docker-compose up</em> will also look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose up\n  Pulling debug-helper (busybox:)...\n  latest: Pulling from library/busybox\n  8ec32b265e94: Pull complete\n  Digest: sha256:b37dd066f59a4961024cf4bed74cae5e68ac26b48807292bd12198afa3ecb778\n  Status: Downloaded newer image for busybox:latest\n  Starting hello-front-dev          ... done\n  Creating react-app_debug-helper_1 ... done\n  Attaching to react-app_debug-helper_1, hello-front-dev\n  react-app_debug-helper_1 exited with code 0\n  \n  hello-front-dev | \n  hello-front-dev | &gt; react-app@0.1.0 start\n  hello-front-dev | &gt; react-scripts start</code></pre></div>\n<p>This is completely expected as it's just a toolbox. Let's use it to send a request to hello-front-dev and see how the DNS works. While the hello-front-dev is running I'll use <a href=\"https://en.wikipedia.org/wiki/Wget\">wget</a> since it's simple and included in busybox to send a request from the debug-helper to hello-front-dev.</p>\n<p>Wget requires the flag <em>-O</em> with <em>-</em> will output the response to the stdout. And then we'll just add the url: <em>wget -O - URL</em>. With docker-compose we can use <em>docker-compose run SERVICE COMMAND</em> to run a service with a specific command.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose run debug-helper wget -O - http://hello-front-dev:3000\n\n  Creating react-app_debug-helper_run ... done\n  Connecting to hello-front-dev:3000 (172.26.0.2:3000)\n  writing to stdout\n  &lt;!DOCTYPE html&gt;\n  &lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n      &lt;meta charset=&quot;utf-8&quot; /&gt;\n      ...</code></pre></div>\n<p>The URL is really the interesting part here. We simply said to connect to the other service and to that port. The port does not need to be published for other services in the same network to be able to connect to it. The \"ports\" in docker-compose.yml is only for external access.</p>\n<p>Let's do a few alterations to the docker-compose to emphasize this:</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 3210<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n\n  <span class=\"token key atrule\">debug-helper</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox</code></pre></div>\n<p>With <em>docker-compose up</em> the application is available in <a href=\"http://localhost:3210\">http://localhost:3210</a>. But still <em>docker-compose run debug-helper wget -O - <a href=\"http://hello-front-dev:3000\">http://hello-front-dev:3000</a></em> works.</p>\n<picture><img src=\"/static/ecd3aa14ff1220e3f47ddd6b63116a48/efc6e/busybox_networking_drawio.png\" srcset=\"/static/ecd3aa14ff1220e3f47ddd6b63116a48/772e8/busybox_networking_drawio.png 200w,\n/static/ecd3aa14ff1220e3f47ddd6b63116a48/e17e5/busybox_networking_drawio.png 400w,\n/static/ecd3aa14ff1220e3f47ddd6b63116a48/efc6e/busybox_networking_drawio.png 441w\" sizes=\"(max-width: 441px) 100vw, 441px\"></picture>\n<p>As above image illustrates the <em>docker-compose run</em> asks debug-helper to send the request within the\nnetwork. While the browser would send the request from outside of the network.</p>\n<p>Now that you know how easy it is to find other services in a docker-compose.yml and we have nothing to debug we can remove the debug-helper and revert the ports to 3000:3000 in our <em>docker-compose.yml</em>.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.15</h3>\n<h4>Exercise 12.15: Run todo-back in a development container</h4>\n<p>Use the volumes and nodemon to enable development of the backend while it is running inside a container.</p>\n<p>You will also need to rethink the connections between backend and mongo / redis. Thankfully docker-compose can include environment variables that will be passed to the application:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span> \n      <span class=\"token punctuation\">-</span> REDIS_URL=//localhost<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span>\n      <span class=\"token punctuation\">-</span> MONGO_URL=mongodb<span class=\"token punctuation\">:</span>//the_username<span class=\"token punctuation\">:</span>the_password@localhost<span class=\"token punctuation\">:</span>3456/the_database</code></pre></div>\n<blockquote>\n<p>The urls (localhost) are purposefully wrong, you will need to set the correct values</p>\n</blockquote>\n<p>Here is a possibly helpful image:</p>\n<picture><img src=\"/static/e866965c916d7f8e5a8515d3aa16bc44/85ff8/ex_12_15_backend_drawio.png\" srcset=\"/static/e866965c916d7f8e5a8515d3aa16bc44/772e8/ex_12_15_backend_drawio.png 200w,\n/static/e866965c916d7f8e5a8515d3aa16bc44/e17e5/ex_12_15_backend_drawio.png 400w,\n/static/e866965c916d7f8e5a8515d3aa16bc44/85ff8/ex_12_15_backend_drawio.png 467w\" sizes=\"(max-width: 467px) 100vw, 467px\"></picture>\n</div>\n<div class=\"content\">\n<h4>Communications between containers in a more ambitious environment</h4>\n<p>Next we will add a reverse proxy to our docker-compose. A reverse proxy will be the single point of entry to our application and we can hide multiple servers behind it. The final goal will be to set both the react application and the express application behind the reverse proxy. There are multiple different options, here are some examples ordered by initial release from newer to older: Traefik, Caddy, Nginx and Apache.</p>\n<p>Let's pick Nginx, the docker hub page is <a href=\"https://hub.docker.com/_/nginx\">here</a>. Create a file nginx.conf in the project root and take this template for a configuration. We will need to do minor edits to have our application running:</p>\n<p><code class=\"language-text\">nginx.conf</code></p>\n<div class=\"gatsby-highlight\" data-language=\"conf\"><pre class=\"language-conf\"><code class=\"language-conf\"># events is required, but defaults are ok\nevents { }\n\n# A http server, listening at port 80\nhttp {\n  server {\n    listen 80;\n\n    # Requests starting with root (/) are handled\n    location / {\n      # The following 3 lines are required for the hot loading to work (websocket).\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &#39;upgrade&#39;;\n      \n      # Requests are directed to http://localhost:3000\n      proxy_pass http://localhost:3000;\n    }\n  }\n}</code></pre></div>\n<p>And next add Nginx to the docker-compose file. Add a volume as instructed in the docker hub page where the right side is <em>:/etc/nginx/nginx.conf:ro</em>, the final ro declares that the volume will be <i>read-only</i>.</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">  <span class=\"token key atrule\">nginx</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.20.1\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./nginx.conf<span class=\"token punctuation\">:</span>/etc/nginx/nginx.conf<span class=\"token punctuation\">:</span>ro\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 8080<span class=\"token punctuation\">:</span><span class=\"token number\">80</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> reverse<span class=\"token punctuation\">-</span>proxy</code></pre></div>\n<p>with that added we can run docker-compose up and see what happens.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker ps\nCONTAINER ID   IMAGE             COMMAND                  CREATED         STATUS         PORTS                                       NAMES\na02ae58f3e8d   nginx:1.20.1      &quot;/docker-entrypoint.…&quot;   4 minutes ago   Up 4 minutes   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp       reverse-proxy\n5ee0284566b4   hello-front-dev   &quot;docker-entrypoint.s…&quot;   4 minutes ago   Up 4 minutes   0.0.0.0:3000-&gt;3000/tcp, :::3000-&gt;3000/tcp   hello-front-dev</code></pre></div>\n<p>Connecting to <a href=\"http://localhost:8080\">http://localhost:8080</a> will lead to a familiar looking page with 502 status. </p>\n<p>This is because directing requests to <a href=\"http://localhost:3000\">http://localhost:3000</a> leads to nowhere as the nginx container does not have any application running in port 3000. By definition localhost refers to the current computer used to access it. With containers localhost is unique for each container, leading to the container itself.</p>\n<p>Let's test this by going inside the nginx container and using curl to send a request to the application itself. In our usage curl is similar to wget, but won't need any flags.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker exec -it reverse-proxy bash  \n\nroot@374f9e62bfa8:/# curl http://localhost:80\n  &lt;html&gt;\n  &lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;\n  ...</code></pre></div>\n<p>To help us docker-compose set up a network when we ran docker-compose up and had all of the containers join the network. A DNS makes sure we can find the other container. The containers are each given two names: the service name and the container name.</p>\n<p>Since we are inside the container now we can also test the DNS! Let's curl the service name (app) in port 3000</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">root@374f9e62bfa8:/# curl http://app:3000\n  <span class=\"token doctype\">&lt;!DOCTYPE html></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    ...\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span>\n      <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>description<span class=\"token punctuation\">\"</span></span>\n      <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Web site created using create-react-app<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token punctuation\">/></span></span>\n    ...</code></pre></div>\n<p>That is it! Let's replace the proxy_pass address in nginx.conf with that one.</p>\n<p>If you are still encountering 503, make sure that the create-react-app has been built first. You can read the logs output from the docker-compose up.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercises 12.16. - 12.18.</h3>\n<h4>Exercise 12.16: Setup nginx in front of todo-front</h4>\n<blockquote>\n<p>In this exercise, submit the entire development environment, including the development Dockerfile AND docker-compose.yml.</p>\n</blockquote>\n<p>Create a development docker-compose yml with nginx and our todo react-app.</p>\n<picture><img src=\"/static/a5c3b8d70abca3569ed532e053af7bc7/15d25/ex_12_16_nginx_front.png\" srcset=\"/static/a5c3b8d70abca3569ed532e053af7bc7/772e8/ex_12_16_nginx_front.png 200w,\n/static/a5c3b8d70abca3569ed532e053af7bc7/e17e5/ex_12_16_nginx_front.png 400w,\n/static/a5c3b8d70abca3569ed532e053af7bc7/15d25/ex_12_16_nginx_front.png 497w\" sizes=\"(max-width: 497px) 100vw, 497px\"></picture>\n<p>You should use the following structure to make the next exercise easier:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">├── react-app\n└── docker-compose.dev.yml</code></pre></div>\n<p>You can use <em>-f</em> flag to specify a file in case you want to have multiple, e.g. <em>docker-compose -f docker-compose.dev.yml up</em></p>\n<h4>Exercise 12.17: Setup nginx in front of todo-back</h4>\n<blockquote>\n<p>In this exercise, submit the entire development environment, including the development Dockerfile AND docker-compose.yml.</p>\n</blockquote>\n<p>Add the express-app to the development docker-compose yml in development mode.</p>\n<p>Add a new location to the nginx.conf so that requests to /api are proxied to the backend. Something like this should do the trick:</p>\n<div class=\"gatsby-highlight\" data-language=\"conf\"><pre class=\"language-conf\"><code class=\"language-conf\">  server {\n    listen 80;\n\n    # Requests starting with root (/) are handled\n    location / {\n      # The following 3 lines are required for the hot loading to work (websocket).\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &#39;upgrade&#39;;\n      \n      # Requests are directed to http://localhost:3000\n      proxy_pass http://localhost:3000;\n    }\n\n    # Requests starting with /api are handled\n    location /api {\n      ...\n    }\n  }</code></pre></div>\n<p>The <em>proxy_pass</em> directive has an interesting feature with a trailing slash. As we are using the path <em>/api</em> for location but the backend application only answers in paths <em>/</em> or <em>/todos</em> we will want the <em>/api</em> to be removed from the request. In other words even though the browser will send a GET request to <em>/api/todos/1</em> we want the nginx to proxy the request to <em>/todos/1</em>. This is done by adding a trailing slash <em>/</em> to the url at the end of <em>proxy_pass</em>.</p>\n<p>This is a <a href=\"https://serverfault.com/questions/562756/how-to-remove-the-path-with-an-nginx-proxy-pass\">common issue</a></p>\n<picture><img src=\"/static/356d6b54ad3287d7e031093366b578bf/ace37/nginx_trailing_slash_stackoverflow.png\" srcset=\"/static/356d6b54ad3287d7e031093366b578bf/772e8/nginx_trailing_slash_stackoverflow.png 200w,\n/static/356d6b54ad3287d7e031093366b578bf/e17e5/nginx_trailing_slash_stackoverflow.png 400w,\n/static/356d6b54ad3287d7e031093366b578bf/ace37/nginx_trailing_slash_stackoverflow.png 666w\" sizes=\"(max-width: 666px) 100vw, 666px\"></picture>\n<p>This illustratrates what we are looking for:</p>\n<picture><img src=\"/static/1e05f9f899e31b8ec9044169ab3fb400/15d25/ex_12_17_nginx_back.png\" srcset=\"/static/1e05f9f899e31b8ec9044169ab3fb400/772e8/ex_12_17_nginx_back.png 200w,\n/static/1e05f9f899e31b8ec9044169ab3fb400/e17e5/ex_12_17_nginx_back.png 400w,\n/static/1e05f9f899e31b8ec9044169ab3fb400/15d25/ex_12_17_nginx_back.png 497w\" sizes=\"(max-width: 497px) 100vw, 497px\"></picture>\n<p>Please use the following structure for this exercise:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">├── express-app\n├── react-app\n└── docker-compose.dev.yml</code></pre></div>\n<h4>Exercise 12.18: Connect todo-front to todo-back</h4>\n<blockquote>\n<p>In this exercise, submit the entire development environment, including both express and react applications, Dockerfiles and docker-compose.yml.</p>\n</blockquote>\n<p>Make sure that the todo-front works with todo-back. It will require changes to the <em>REACT_APP_BACKEND_URL</em> environmental variable.</p>\n<p>If you already got this working during a previous exercise you may skip this.</p>\n</div>\n<div class=\"content\">\n<h3>Tools for Production</h3>\n<p>Containers are fun tools to use in development, but the best use case for them is in the production environment. There are a number of more powerful tools than docker-compose to run containers in production.</p>\n<p>Tools like Kubernetes allow us to manage containers on a completely new level. It basically hides away the physical machines and allows us developers to worry less about the infrastructure.</p>\n<p>If you are interested in learning more in depth about containers come to the <a href=\"https://devopswithdocker.com\">DevOps with Docker</a> course and you can find more about Kubernetes in the advanced 5 credit <a href=\"https://devopswithkubernetes.com\">DevOps with Kubernetes</a> course. You should now have the skills to complete both of them.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercises 12.19.</h3>\n<h4>Exercise 12.19:</h4>\n<blockquote>\n<p>In this exercise, submit the entire production environment, including both express and react applications, Dockerfiles and docker-compose.yml.</p>\n</blockquote>\n<p>Create a production docker-compose.yml with all of the services, nginx, react-app, express-app, mongodb and redis.</p>\n<p>Please use the following structure for this exercise:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">├── express-app\n├── react-app\n└── docker-compose.yml</code></pre></div>\n<p>This was the last exercise in this section. It's time to push your code to GitHub and mark all of your finished exercises to the <a href=\"https://studies.cs.helsinki.fi/stats\">exercise submission system</a>.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/3c94fa433f40d6b2797b2e0c31a5cba3/part-12.svg"},"part":12,"letter":"c","lang":"en"}}},"pageContext":{"part":12,"letter":"c","lang":"en"}}}