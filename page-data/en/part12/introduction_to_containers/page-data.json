{"componentChunkName":"component---src-templates-content-template-js","path":"/en/part12/introduction_to_containers","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>Software development includes the whole lifecycle from envisioning the software to programming and to releasing the software to the end users and even maintaining it. This part will introduce containers, a modern tool utilized in the latter parts of the software lifecycle.</p>\n<p>Containers encapsulate your application into a single package. This package will then include all of the dependencies with the application so that each container can run isolated from each other.</p>\n<p>Containers can be compared to virtual machines (VM) which are used to run multiple operating systems on a single physical machine. Containers are OS-level virtualization which means, among other things, that they allow applications to access only the container's contents and resources given to that container. Whereas VMs run an entire operating system a container runs the software using the host operating system. The resulting difference between VMs and containers is that there is little overhead when running containers; they only need to run a single process.</p>\n<p>As containers are relatively lightweight, at least compared to virtual machines, they can be quick to scale. And they isolate the software running inside enabling the software to run identically almost anywhere. As such they are the go to option in any cloud environment or application with more than a handful of users.</p>\n<p>Cloud services like AWS, Google Cloud and Microsoft Azure all support containers in multiple different forms. As an example, AWS Fargate and Google Cloud Run run containers as serverless - where the application container does not even need to be running if it is not used. You can also install container runtime on most machines and run containers there yourself - including your personal machine. </p>\n<p>So containers are used in clouds and development. What are the benefits of using one? Here are two fairly relatable and common scenarios:</p>\n<blockquote>\n<p>Scenario 1: You are developing a new application that needs to run on the same machine as a legacy application. Both require different versions of Node installed.</p>\n</blockquote>\n<p>You can probably use nvm, virtual machines or some sort of dark magic to get them running at the same time. However, containers are an excellent solution as you can run both applications in their respective containers. They are isolated from each other and do not interfere.</p>\n<blockquote>\n<p>Scenario 2: Your application runs on your machine. You need to move the application to a server.</p>\n</blockquote>\n<p>It is not uncommon that the application just does not run there. It may be due to some missing dependency or other differences in the environments. Here containers are an excellent solution since you can run the application in the same environment (container) both on your machine and on the server. It is not perfect: different machines may have different hardware, but you can limit the number of differences between environments.</p>\n<p>Sometimes you may hear about the “Works in my container” issue - this is often a usage error.</p>\n<h3>About this part</h3>\n<p>In this part, the focus of our attention will not be on the software code. Instead, we are interested in the configuration of the environment in which the software is executed. As a result, the exercises may not contain any coding, the applications are available to you through GitHub and your tasks will include configuring them. The exercises are to be submitted to <i>a single GitHub repository</i> which will include all of the source code and configuration you do during this part.</p>\n<p>Only the core parts, 1 through 5, are required to be completed before this part. As you will need basic knowledge of Node, Express and React.</p>\n</div>\n<div class=\"tasks\">\n<h1>Warning</h1>\n<p>Since we are stepping right outside of our comfort zone as JavaScript developers this part may require you to do a detour and familiarize yourself with shell / command line / command prompt / terminal before getting started.</p>\n<p>If you've only ever used a graphical user interface and never touched e.g. linux or terminal on mac or get stuck in the first exercises I recommend doing the Part 1 of \"Computing tools for CS studies\" first: <a href=\"https://tkt-lapio.github.io/en/\">https://tkt-lapio.github.io/en/</a>. Skip the section for \"SSH connection\" and Exercise 11. Otherwise it includes everything you're going to need to get started here! </p>\n<h3>Exercise 12.1</h3>\n<h4>Exercise 12.1: Using a computer (without graphical user interface)</h4>\n<p>Step 1: Read the text below the Warning header.</p>\n<p>Step 2: Run <em>curl <a href=\"http://helsinki.fi\">http://helsinki.fi</a></em> and save the output into a file. Submit that file into your repository.</p>\n</div>\n<div class=\"content\">\n<h3>Submitting exercises and earning credits</h3>\n<p>Exercises are submitted via the <a href=\"https://studies.cs.helsinki.fi/stats/\">submissions system</a> just like in the previous parts. Note that, exercises in this part are submitted <i>to a different course instance</i>.</p>\n<p>This part on containers is 1 credit.</p>\n<p>Once you have completed the exercises and want to get the credits, let us know through the exercise submission system that you have completed the course:</p>\n<picture><img src=\"/static/ba7a651de70d2d2e13697df135255a90/5a190/23.png\" alt=\"Submitting exercises for credits\" srcset=\"/static/ba7a651de70d2d2e13697df135255a90/772e8/23.png 200w,\n/static/ba7a651de70d2d2e13697df135255a90/e17e5/23.png 400w,\n/static/ba7a651de70d2d2e13697df135255a90/5a190/23.png 800w,\n/static/ba7a651de70d2d2e13697df135255a90/c1b63/23.png 1200w,\n/static/ba7a651de70d2d2e13697df135255a90/29007/23.png 1600w,\n/static/ba7a651de70d2d2e13697df135255a90/50e7d/23.png 1738w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>You can download the certificate for completing this part by clicking one of the flag icons. The flag icon corresponds to the certificate's language.</p>\n<h3>Tools of the trade</h3>\n<p>The material and the exercises can be completed with</p>\n<ul>\n<li><a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\">WSL 2 terminal</a> on Windows</li>\n<li>Terminal on Mac</li>\n<li>Command Line on a Linux</li>\n</ul>\n<h3>Installing everything required for this part</h3>\n<p>To make sure that you are ready to start with this part let's begin by installing the required software. This will be one of the largest obstacle for us, since the tools will require superuser access on the computer. This is due to the fact that the tools will have access to your operating systems kernel. We will talk more about what this means in the next section.</p>\n<p>The material is built around Docker, a set of products that we will use for containerization and for the management of containers.</p>\n<p>Depending on your operating system choose install instructions from the link below. Note that they may have multiple different options for your operating system. </p>\n<ul>\n<li><a href=\"https://docs.docker.com/get-docker/\">Get Docker</a></li>\n</ul>\n<p>Now that that headache is hopefully over let's make sure that our versions match. Yours might be a bit higher than here:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker -v\nDocker version <span class=\"token number\">20.10</span>.5, build 55c4c88</code></pre></div>\n<h3>Containers and images</h3>\n<p>There are two core concepts when starting with containers and they are easy to confuse:</p>\n<p><strong>Container</strong> is a runtime instance of an <strong>image</strong>.</p>\n<p>So while we can say \"Containers package software into standardized units\" we can also say \"Images include all of the code, dependencies and instructions on how to run the application\" which sounds a lot like \"Images package software\" as well.</p>\n<p>To help with the confusion everyone just talks about containers. But you can never <strong>actually</strong> build a container or download one, since they only exist runtime. Images on the other hand are <strong>immutable</strong> files. They can not be changed but they can be created and they can be used to create new images by adding new <strong>layers</strong> on top of the existing ones.</p>\n<p>Cooking metaphor:</p>\n<ul>\n<li>Image is pre-cooked, frozen treat.</li>\n<li>Container is the delicious treat.</li>\n</ul>\n<p><a href=\"https://www.docker.com/\">Docker</a> is the most popular containerization technology and pioneered the standard most use now. It will enable us to leverage all of the benefits of containers. Docker is a set of products that help us manage images and containers. The docker engine will take care of turning the immutable files, images, into containers.</p>\n<p>For managing the docker containers, there is also <a href=\"https://docs.docker.com/compose/\">Docker Compose</a>. It is used to <strong>orchestrate</strong> (control) multiple containers at the same time. We will use Docker Compose to set up complex local development environments quickly. For the final version of our node development environment, we will try to eliminate the need to install Node.</p>\n<p>There are a number of concepts we need to go over, but we will skip those for now and learn about Docker first! One of my favorite features is the capability to handle running containers even if they are not yet downloaded on our device.</p>\n<p>The command structure is the following: <em>container run <i>IMAGE-NAME</i></em>. So we will tell docker to create a container from an image.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">§ docker container run hello-world</code></pre></div>\n<p>There will be a lot of output but I will split it into multiple sections that we can decipher it together. The lines are numbered by me so that it is easier to follow the explanation, your output will not have the numbers:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>. Unable to <span class=\"token function\">find</span> image <span class=\"token string\">'hello-world:latest'</span> locally\n<span class=\"token number\">2</span>. latest: Pulling from library/hello-world\n<span class=\"token number\">3</span>. b8dfde127a29: Pull complete\n<span class=\"token number\">4</span>. Digest: sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c\n<span class=\"token number\">5</span>. Status: Downloaded newer image <span class=\"token keyword\">for</span> hello-world:latest</code></pre></div>\n<p>It's downloaded a new image for hello-world from \"Docker Hub\". You can see the docker hub page for the image with your browser here: <a href=\"https://hub.docker.com/_/hello-world\">https://hub.docker.com/_/hello-world</a></p>\n<p>The first part of the message states that we did not have \"hello-world:latest\" yet. This reveals a bit of detail about images themselves; image names consist of multiple parts, kind of like an url. An image name is in the following format: </p>\n<ul>\n<li><em>registry/organisation/image:tag</em></li>\n</ul>\n<p>In this case the 3 missing fields defaulted to: </p>\n<ul>\n<li><em>index.docker.io/library/hello-world:latest</em></li>\n</ul>\n<p>Second row shows the organisation name, \"library\" where it will get the image. In the Docker Hub url the \"library\" is shortened to _.</p>\n<p>The 3rd and 5th rows only show the status. But 4th row may be interesting: each image has a unique digest based on the layers. The digest is used by docker to identify that an image is the same if you try to pull it again.</p>\n<p>So it did some pulling and then output information about the <strong>image</strong>. It then gave the status that a new version of hello-world:latest was indeed downloaded. You can try pulling the image with <em>docker image pull hello-world</em>.</p>\n<p>The following output was from the container itself. It also explains what happened when we ran <em>docker container run hello-world</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">Hello from Docker<span class=\"token operator\">!</span>\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n <span class=\"token number\">1</span>. The Docker client contacted the Docker daemon.\n <span class=\"token number\">2</span>. The Docker daemon pulled the <span class=\"token string\">\"hello-world\"</span> image from the Docker Hub.\n    <span class=\"token punctuation\">(</span>amd64<span class=\"token punctuation\">)</span>\n <span class=\"token number\">3</span>. The Docker daemon created a new container from that image <span class=\"token function\">which</span> runs the\n    executable that produces the output you are currently reading.\n <span class=\"token number\">4</span>. The Docker daemon streamed that output to the Docker client, <span class=\"token function\">which</span> sent it\n    to your terminal.\n\nTo try something <span class=\"token function\">more</span> ambitious, you can run an Ubuntu container with:\n $ docker container run -it ubuntu <span class=\"token function\">bash</span>\n\nShare images, automate workflows, and <span class=\"token function\">more</span> with a <span class=\"token function\">free</span> Docker ID:\n https://hub.docker.com/\n\nFor <span class=\"token function\">more</span> examples and ideas, visit:\n https://docs.docker.com/get-started/</code></pre></div>\n<p>The output contains a few new things for us to learn. Docker daemon is a background service that makes sure the containers are running, and we use the docker client to interact with the daemon. What we just did is we ran a container that contained the hello-world application and saw what it printed out.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.2</h3>\n<p>Some of these exercises do not generate anything for you to submit.</p>\n<p>Instead use <a href=\"https://man7.org/linux/man-pages/man1/script.1.html\">script</a> to record commands you have used; try it yourself with <em>script</em> to start recording, <em>echo \"hello\"</em> to generate some output, and <em>exit</em> to stop recording. It saves your actions into a file names \"typescript\".</p>\n<p>If <em>script</em> does not work, you can just copypaste all commands you used into a text file.</p>\n<h4>Exercise 12.2: Running your second container</h4>\n<blockquote>\n<p>Use <em>script</em> to record what you do, save the generated file into the repository as your answer.</p>\n</blockquote>\n<p>The hello-world output gave us an \"ambitious\" task to do. Do the following</p>\n<p>Step 1. Run an Ubuntu container with the command given by hello-world</p>\n<p>The step 1 will connect you straight into the container with bash. You will have an access to all the files and tools inside.</p>\n<p>Step 2. Create directory <code class=\"language-text\">/usr/src/app</code></p>\n<p>Step 3. Create a file <code class=\"language-text\">/usr/src/app/index.js</code></p>\n<p>Step 4. Run <code class=\"language-text\">exit</code> to quit from the container</p>\n<p>Google should be able to help you with creating directories and files.</p>\n</div>\n<div class=\"content\">\n<h3>Ubuntu image</h3>\n<p>The command you just used to run the ubuntu container, <em>docker container run -it ubuntu bash</em>, contains a few additions to our hello-world. Let's see the --help to get a better understanding. I'll cut some of the output so we can focus on the relevant parts.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container run --help\n\nUsage:  docker container run <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> IMAGE <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>ARG<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\nRun a <span class=\"token builtin class-name\">command</span> <span class=\"token keyword\">in</span> a new container\n\nOptions:\n  <span class=\"token punctuation\">..</span>.\n  -i, --interactive                    Keep STDIN <span class=\"token function\">open</span> even <span class=\"token keyword\">if</span> not attached\n  -t, --tty                            Allocate a pseudo-TTY\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>The options, or flags, <em>-it</em> make sure we can interact with the container. And after the image, in this case ubuntu, we have the command to be executed inside the container when we start it. You can try other commands that the ubuntu image might have the tools for, for example, try <em>docker container run --rm ubuntu ls</em>. The <em>ls</em> command will list all of the files in the directory and <em>--rm</em> will remove the container after execution.</p>\n<p>Let's continue with our first ubuntu container with the <strong>index.js</strong> file inside of it. It has stopped running since we exited it. We can list all of the containers with <em>container ls -a</em>, the <em>-a</em> (or --all) will list containers that have already been exited.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">ls</span> -a\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                       PORTS     NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">3</span> minutes ago    Exited <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">6</span> seconds ago               hopeful_clarke</code></pre></div>\n<p>The identifier can be used to interact with the container. Although most commands accept the container name as well. The name of the container was automatically generated to be <strong>\"hopeful_clarke\"</strong> in my case.</p>\n<p>The container has already exited, but we can start it again with the start command that will accept the id or name of the container as parameter: <em>start <i>CONTAINER-ID-OR-CONTAINER-NAME</i></em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker start hopeful_clarke\nroot@b8548b9faec3:/<span class=\"token comment\">#</span></code></pre></div>\n<p>The start command will start the same container we had previously. Unfortunately, we forgot to start it with the flag <em>--interactive</em> so we can not interact with it. Let's kill it with the <em>kill <i>CONTAINER-ID-OR-CONTAINER-NAME</i></em> command and try again.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">ls</span> -a\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                      PORTS     NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">13</span> minutes ago   Up <span class=\"token number\">47</span> seconds                         hopeful_clarke\n\n$ docker <span class=\"token function\">kill</span> hopeful_clarke\nhopeful_clarke\n\n$ docker start -i hopeful_clarke\nroot@b8548b9faec3:/<span class=\"token comment\">#</span></code></pre></div>\n<p>Let's edit the index.js and add something to execute. We are just missing the tools to edit the file with. Nano will be a good text editor for now. Google should give us the install instructions. We will just omit using sudo since we are already root.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@b8548b9faec3:/# apt-get update\n...\n\nroot@b8548b9faec3:/# apt-get -y install nano\n...\n\nroot@b8548b9faec3:/# nano /usr/src/app/index.js</code></pre></div>\n<p>Now we have nano installed and can start editing files!</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.3 - 12.4</h3>\n<h4>Exercise 12.3: Ubuntu 101</h4>\n<blockquote>\n<p>Use <em>script</em> to record what you do, save the generated file into the repository as your answer.</p>\n</blockquote>\n<p>Edit the <em>/usr/src/app/index.js</em> file inside the container with the now installed nano and add the following line</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>If Nano isn't familiar you can ask in the chat or google.</p>\n<h4>Exercise 12.4: Ubuntu 102</h4>\n<blockquote>\n<p>Use <em>script</em> to record what you do, save the generated file into the repository as your answer.</p>\n</blockquote>\n<p>Install Node while inside the container and run the index file with <em>node /usr/src/app/index.js</em> in the container.</p>\n<p>The instructions for installing Node are sometimes hard to find so here is something you can copy-paste:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -sL https://deb.nodesource.com/setup_16.x <span class=\"token operator\">|</span> <span class=\"token function\">bash</span>\n<span class=\"token function\">apt</span> <span class=\"token function\">install</span> -y nodejs</code></pre></div>\n<p>You will need to install the <em>curl</em> into the container. It is installed in the same way as you did with <em>nano</em>.</p>\n</div>\n<div class=\"content\">\n<h3>Other docker commands</h3>\n<p>Now that we have node installed in the container we can execute <em>node /usr/src/app/index.js</em> in the container! Let's create a new image from the container. The <em>commit <i>CONTAINER-ID-OR-CONTAINER-NAME</i> <i>NEW-IMAGE-NAME</i></em> will create a new image that includes the changes we have made. You can use <em>container diff</em> to check for the changes between the original image and container before doing so.</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ docker commit hopeful_clarke hello-node-world</code></pre></div>\n<p>You can list your images with <em>image ls</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ docker-fs docker image ls\nREPOSITORY                                      TAG         IMAGE ID       CREATED         SIZE\nhello-node-world                                latest      eef776183732   9 minutes ago   252MB\nubuntu                                          latest      1318b700e415   2 weeks ago     72.8MB\nhello-world                                     latest      d1165f221234   5 months ago    13.3kB</code></pre></div>\n<p>You can now run the new image as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">docker run -it hello-node-world bash\nroot@4d1b322e1aff:/# node /usr/src/app/index.js</code></pre></div>\n<p>There are multiple ways to achieve the same conclusion. Let's go through a better solution starting by running <em>container rm</em> to remove the old container.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container <span class=\"token function\">ls</span> -a\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                       PORTS     NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">31</span> minutes ago   Exited <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">9</span> seconds ago               hopeful_clarke\n\n$ docker container <span class=\"token function\">rm</span> hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p>Create the index.js file and write <em>console.log('Hello, World')</em> inside it. No need for containers yet.</p>\n<p>Next let's skip installing node altogether. Since docker images are found in Docker Hub we can use this <a href=\"https://hub.docker.com/_/node\">https://hub.docker.com/_/node</a>. That image has node already installed, and we only need to pick a version. </p>\n<p>By the way, the <em>container run</em> accepts <em>--name</em> flag that we can use to give a name for the container.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker container run -it --name hello-node node:16 <span class=\"token function\">bash</span></code></pre></div>\n<p>While we are inside the container on this terminal, open another terminal and use the <em>container cp</em> command to copy file from your own machine to the container.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ docker <span class=\"token function\">cp</span> ./index.js hello-node:/usr/src/app/index.js</code></pre></div>\n<p>And now we can run <em>node /usr/src/app/index.js</em> in the container.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/3c94fa433f40d6b2797b2e0c31a5cba3/part-12.svg"},"part":12,"letter":"a","lang":"en"}}},"pageContext":{"part":12,"letter":"a","lang":"en"}}}