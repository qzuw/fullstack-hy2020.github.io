{"componentChunkName":"component---src-templates-content-template-js","path":"/en/part12/building_and_configuring_environments","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>In the previous section we used two different base images: ubuntu and node and did some manual work to get a simple \"Hello, World!\" running. The basic tools we learned during that process are extremely useful. In this section, we will learn how to build containers and configure environments for our own applications. How these can be managed for both React frontend and node backend applications and in addition take a quick peek at other possible backend options you may encounter.</p>\n<h3>Dockerfile</h3>\n<p>Instead of modifying a container by copying files inside there we can create a new image that contains the \"Hello, World!\" application. The tool for this is the Dockerfile. Dockerfile is a simple text file that contains all of the instructions for creating an image. Let's create an example Dockerfile from the \"Hello, World!\" application.</p>\n<p>If you did not already, create a directory on your own machine and create a file called Dockerfile. Let's also put a index.js containing <em>console.log('Hello, World!')</em> next to the Dockerfile. Your directory structure should look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── index.js\n└── Dockerfile</code></pre></div>\n<p>inside that Dockerfile we will tell the image 3 things:</p>\n<ol>\n<li>Use the node:16 as the base for our image, we want everything node 16 contains to be available for this image.</li>\n<li>Include the index.js inside the image, so we don't need to manually copy it into the container</li>\n<li>When we run a container from the image, use node to execute the index.js file.</li>\n</ol>\n<p>This will translate into a basic Dockerfile. The file is usually placed at the root of the project.</p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>16\n\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n\n<span class=\"token keyword\">COPY</span> ./index.js ./index.js\n\n<span class=\"token keyword\">CMD</span> node index.js</code></pre></div>\n<p>FROM instruction will tell us that the base is node:16. COPY instruction will copy the file to the file. And CMD instructs what will be executed when <em>docker run</em> is used. CMD is the <em>default</em> command that can then be overwritten with the parameter given after image name. See <em>docker run --help</em> if you forgot.</p>\n<p>I included one additional instruction, WORKDIR makes sure we don't interfere with the contents that the image already had. It will ensure all of the following commands will be in the container in directory /usr/src/app, if the directory doesn't exist it will create it. </p>\n<p>If we do not specify a WORKDIR we risk overwriting unrelated, but important files by accident. If you check the root (<em>/</em>) of the node:16 with <em>docker run node:16 ls</em> image you can notice all of the directories and files that are already included in the image. That is due to the fact that we use node as the base image. The node image already contained all of those files, we just added our own. </p>\n<p>Now we can use the command <em>docker build</em> to build an image based on the Dockerfile. Let's spice up the command with one additional flag: <em>-t</em>, this will help us name the image:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker build -t fs-hello-world . \n[+] Building 3.9s (8/8) FINISHED\n...</code></pre></div>\n<p>So the result is \"docker please build with tag fs-hello-world the Dockerfile in this directory\". You can point to any Dockerfile, but in our case simple dot will mean the Dockerfile in this directory. After the build finished you can run it with <em>docker run fs-hello-world</em>.</p>\n<p>Images are just files. They can be moved around, downloaded and deleted. You can list the images you have locally with <em>docker image ls</em>, delete them with <em>docker image rm</em>. See what other command you have available with <em>docker image --help</em>.</p>\n<h3>More meaningful image</h3>\n<p>Moving an express server to a container should be as simple as moving the \"Hello, World!\" application. The only difference is that there are more files. Thankfully <em>COPY</em> instruction can handle all that. Let's delete the index.js and create a new express server. Lets use express-generator to create a basic express application.</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ npx express-generator\n  ...\n  \n  install dependencies:\n    $ npm install\n\n  run the app:\n    $ DEBUG=playground:* npm start</code></pre></div>\n<p>First, let's run the application to get an idea of what we just created. Note that the command to run the application may be different from you, my directory was called playground.</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ npm install\n\n$ DEBUG=playground:* npm start\n\n  playground:server Listening on port 3000 +0ms</code></pre></div>\n<p>Great, so now we can navigate to <a href=\"http://localhost:3000\">http://localhost:3000</a> and the app is running there.</p>\n<p>Containerizing that should be easy based on the previous example.</p>\n<ol>\n<li>Use node as base</li>\n<li>Set working directory so we don't interfere with the contents of the base image</li>\n<li>Copy ALL of the files in this directory to the image</li>\n<li>Start with DEBUG=playground:* npm start</li>\n</ol>\n<p>The Dockerfile can again be placed at the root of the project.</p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>16\n\n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">CMD</span> DEBUG=playground<span class=\"token punctuation\">:</span>* npm start</code></pre></div>\n<p>Let's build the image from that, <em>docker build -t express-server .</em> and run it with <em>docker run -p 3123:3000 express-server</em>. The <em>-p</em> flag will inform docker that a port from the host machine should be opened and directed to a port in the container. And the format is <em>-p host:application</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ docker run -p 3123:3000 express-server\n\n&gt; playground@0.0.0 start\n&gt; node ./bin/www\n\nTue, 29 Jun 2021 10:55:10 GMT playground:server Listening on port 3000</code></pre></div>\n<blockquote>\n<p>If yours doesn't work, skip to the next section where I explain why it doesn't work (even if you followed the steps).</p>\n</blockquote>\n<p>Looks like it is working! Let's test it by sending a GET request to <a href=\"http://localhost:3123/\">http://localhost:3123/</a>.</p>\n<p>Shutting it down is a headache at the moment, use another terminal and <em>docker kill</em> command to kill the application. The <em>docker kill</em> will send a kill signal (SIGKILL) to the application to force it to shut down. As an argument it needs the name or id of the container.</p>\n<p>Here I choose to kill it with the ID. The beginning of the ID is enough for docker to know which container I mean.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker container ls\n  CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS         PORTS                                       NAMES\n  48096ca3ffec   express-server   &quot;docker-entrypoint.s…&quot;   9 seconds ago   Up 6 seconds   0.0.0.0:3123-&gt;3000/tcp, :::3123-&gt;3000/tcp   infallible_booth\n\n$ docker kill 48\n  48</code></pre></div>\n<p>In the future let's just use the same port outside of the container as the application runs in. This is just so we don't have to remember which one we happened to choose.</p>\n<h4>Fixing potential issues we created by copy-pasting</h4>\n<p>There are a few steps we need to change to create a more comprehensive Dockerfile. It may even be that the above example doesn't work in all cases because we skipped a step.</p>\n<p>We ran npm install on our machines, <strong>node package manager</strong> may install operating system specific dependencies during install step. As we use the COPY instruction to copy all of the node_modules into the image we may move non-functional parts as well.</p>\n<p>This is critical to think about when we build our images. It's best to do most things such as to run <em>npm install</em> inside the container.</p>\n<p>The file .dockerignore is very similar to .gitignore, you can use that to prevent unwanted files from being copied to your image. For example the contents could be</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.dockerignore\n.gitignore\nnode_modules\nDockerfile</code></pre></div>\n<p>However, in our case dockerignore isn't the only thing required. We will need to install the dependencies during the build step.</p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">RUN</span> npm install\n\n<span class=\"token keyword\">CMD</span> DEBUG=playground<span class=\"token punctuation\">:</span>* npm start</code></pre></div>\n<p>Instead of using npm install, npm offers a much better tool for installing dependencies, the <em>ci</em> command.</p>\n<p>Differences between ci and install:</p>\n<ul>\n<li>install may update the package-lock.json</li>\n<li>install may install different version of a dependency if you have ^ or ~ in the version of the dependency.</li>\n<li>ci will delete the node_modules folder before installing anything</li>\n<li>ci will follow the package-lock.json and does not alter any files</li>\n</ul>\n<p>So in short: <em>ci</em> creates realiable builds, while <em>install</em> is the one to use when you want to install new dependencies.</p>\n<p>As we are not installing anything new during the build step, and we don't want the versions to suddenly change, we will use <em>ci</em></p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">CMD</span> DEBUG=playground<span class=\"token punctuation\">:</span>* npm start</code></pre></div>\n<p>Even better, we can use <em>npm ci --only-production</em> to not waste time installing development dependencies.</p>\n<blockquote>\n<p>As you noticed in the comparison list; npm ci will delete the node_modules folder so creating the .dockerignore did not matter. However, .dockerignore is an amazing tool when you want to optimize your build process. We will talk briefly about these optimizations later.</p>\n</blockquote>\n<p>Now the Dockerfile should work again, try it with <em>docker build -t express-server . &#x26;&#x26; docker run -p 3000:3000 express-server</em></p>\n<p>We set an environment variable <em>DEBUG=playground:*</em> during CMD for the npm start. However, with Dockerfiles we could also use the instruction ENV to set environment variables. Let's do that.</p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">ENV</span> DEBUG=playground<span class=\"token punctuation\">:</span>*\n\n<span class=\"token keyword\">CMD</span> npm start</code></pre></div>\n<blockquote>\n<p><i>If you're wondering what the DEBUG environment variable does, read <a href=\"http://expressjs.com/en/guide/debugging.html#debugging-express\">here</a>.</i></p>\n</blockquote>\n<h4>Dockerfile best practices</h4>\n<p>There are 2 rules of thumb you should follow when creating images:</p>\n<ol>\n<li>Try to create as <strong>secure</strong> of an image as possible</li>\n<li>Try to create as <strong>small</strong> of an image as possible</li>\n</ol>\n<p>Smaller images are more secure by having less attack surface area. And smaller images move faster in deployment pipelines.</p>\n<p>Snyk has a great list of 10 best practices, read them <a href=\"https://snyk.io/blog/10-best-practices-to-containerize-nodejs-web-applications-with-docker/\">here</a>.</p>\n<p>One big neglection we did was having the application running as root instead of using an user. Let's do a final fix to the Dockerfile:</p>\n<p><code class=\"language-text\">Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">USER</span> node\n  \n<span class=\"token keyword\">WORKDIR</span> /usr/src/app\n\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>chown=node<span class=\"token punctuation\">:</span>node . .</code></pre></div>\n</div>\n  \n<div class=\"tasks\">\n<h3>Exercise 12.5.</h3>\n<h4>Exercise 12.5: Containerizing a node application</h4>\n<blockquote>\n<p>In this exercise, submit <i>at least</i> the Dockerfile you created.</p>\n</blockquote>\n<p>The following repository contains an express application in the express-app directory: <a href=\"https://github.com/fullstack-hy2020/part12-containers-applications\">part12-containers-applications</a>. You do not need the other directory yet. Copy the contents into your own repository. The express-app directory includes a README on how to start the application.</p>\n<p>Step 1. Containerize the application by creating a Dockerfile and building an image.</p>\n<p>Step 2. Run the image with the correct ports open. Make sure the visit counter increases when used through a browser.</p>\n<p>Tip: Run the application outside of a container to examine it before starting to containerize.</p>\n</div>\n  \n<div class=\"content\">\n<h4>Using docker-compose</h4>\n<p>In the previous section we created express-server and knew that it runs in port 3000, and ran it with <em>docker build -t express-server . &#x26;&#x26; docker run -p 3000:3000 express-server</em>. This already looks like something you would need to put into a script to remember. Fortunately docker offers us a better solution.</p>\n<p>Docker-compose is another amazing tool, which can help us manage containers. We are going to start using docker-compose as we learn more about containers as it will help us save some time with the configuration.</p>\n<p>Install the docker-compose tool from this link: <a href=\"https://docs.docker.com/compose/install/\">https://docs.docker.com/compose/install/</a>.</p>\n<p>Let's check that it works:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ docker-compose -v\ndocker-compose version 1.29.2, build 5becea4c</code></pre></div>\n<p>And now we can turn the spell into a yaml file:</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3.8'</span>            <span class=\"token comment\"># Version 3.8 is quite new and should work</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>                    <span class=\"token comment\"># The name of the service, can be anything</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> express<span class=\"token punctuation\">-</span>server <span class=\"token comment\"># Declares which image to use</span>\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> .              <span class=\"token comment\"># Declares where to build if image is not found</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>                <span class=\"token comment\"># Declares the ports to publish</span>\n      <span class=\"token punctuation\">-</span> 3000<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span></code></pre></div>\n<p>Save this file as <strong>docker-compose.yml</strong> and place it next to the Dockerfile, at the root of the project.</p>\n<p>Now we can use <em>docker-compose up</em> to build and run the application. If we want to rebuild the image we can use <em>docker-compose up --build</em>.</p>\n<p>You can also run the application in the background with <em>docker-compose up -d</em> (<em>-d</em> for detached) and close it with <em>docker-compose down</em>.</p>\n<p>Creating files like this that <i>declare</i> what you want instead of script files that you need to run in a specific order / a specific number of times is often a great practice.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.6.</h3>\n<h4>Exercise 12.6: docker-compose</h4>\n<blockquote>\n<p>In this exercise, submit <i>at least</i> the docker-compose.yml you created.</p>\n</blockquote>\n<p>Create a docker-compose file that works with the node application from the previous exercise.</p>\n<p>The visit counter is the only feature that is required to be working.</p>\n</div>\n<div class=\"content\">\n<h3>Utilizing containers when developing software</h3>\n<p>When you are developing software, containerization can be used in various ways to improve your quality of life. One of the most useful cases is by bypassing the need to install and configure tools twice.</p>\n<p>It may not be the best option to move your entire development environment into a container, but if that's what you want it's possible. We will revisit this idea at the end of this part. But until then, <i>run the node application itself outside of containers</i>.</p>\n<p>The application we met in the previous exercises can use MongoDB. Let's explore <a href=\"https://hub.docker.com/\">Docker Hub</a> to find a mongodb image. Docker Hub is the default place where docker pulls the images from, you can use other registries as well, but since we are already knee-deep in docker I chose that one. With a quick search there I found <a href=\"https://hub.docker.com/_/mongo\">https://hub.docker.com/_/mongo</a></p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3.8'</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database</code></pre></div>\n<p>The environment variables defined here are explained in the docker hub page:</p>\n<blockquote>\n<p>These variables, used in conjunction, create a new user and set that user's password. This user is created in the admin authentication database and given the role of root, which is a \"superuser\" role.</p>\n</blockquote>\n<p>And since we're only using it in development at the moment we can leave them like that. The last environment variable <em>MONGO_INITDB_DATABASE</em> will tell mongo to create a database with that name. Let's save that as the docker-compose.yml in the directory.</p>\n<p>Now start the mongo with <em>docker-compose up -d</em>, it will run it in the background and you can view the logs with <em>docker-compose logs -f</em>, the _-f will ensure we <i>follow</i> the logs.</p>\n<p>As said previously, now we do not want to run the node application inside a container. We'll explore that option in the future but for now it's easier to develop the application if it's not in a container.</p>\n<p>Run the good old npm install first and let's start the application with the relevant environment variable, you can modify the code to set them as the defaults or use .env file. I'll just throw them in with the start to help you copy-paste.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ MONGO_URL=mongodb://localhost:3456/the_database npm run dev</code></pre></div>\n<p>This won't be enough; we need to create a user to be authorized inside of the container. The url <a href=\"http://localhost:3000/todos\">http://localhost:3000/todos</a> leads to an authentication error.</p>\n<h4>Bind mount</h4>\n<p>In the MongoDB Docker Hub page under \"Initializing a fresh instance\" is the info on how to execute js to initialize the database and an user for it.</p>\n<p>Let's create a file <em>mongo-init.js</em> and place it in the mongo directory of the express project.</p>\n<p><code class=\"language-text\">mongo-init.js</code></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">db<span class=\"token punctuation\">.</span><span class=\"token function\">createUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  user<span class=\"token operator\">:</span> <span class=\"token string\">'the_username'</span><span class=\"token punctuation\">,</span>\n  pwd<span class=\"token operator\">:</span> <span class=\"token string\">'the_password'</span><span class=\"token punctuation\">,</span>\n  roles<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      role<span class=\"token operator\">:</span> <span class=\"token string\">'dbOwner'</span><span class=\"token punctuation\">,</span>\n      db<span class=\"token operator\">:</span> <span class=\"token string\">'the_database'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndb<span class=\"token punctuation\">.</span><span class=\"token function\">createCollection</span><span class=\"token punctuation\">(</span><span class=\"token string\">'todos'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndb<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> text<span class=\"token operator\">:</span> <span class=\"token string\">'Write code'</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndb<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> text<span class=\"token operator\">:</span> <span class=\"token string\">'Learn about containers'</span><span class=\"token punctuation\">,</span> done<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>It will initialize the database with an user and a few todos. Now we just need to get it inside the container at startup.</p>\n<p>We could create a new image FROM mongo and COPY the file inside or we can use a bind mount to mount the init-mongo.js to the container. Let's do the latter.</p>\n<p>With <em>container run</em> we can add <em>-v</em> flag with the syntax <em>-v FILE-IN-HOST:FILE-IN-CONTAINER</em>, but let's skip that and add it to the docker-compose.yml. The format is the same, first host and then container:</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js</code></pre></div>\n<p>Mounting the file will mean that the mongo-init file in the mongo folder is the same as the mongo-init file in the containers /docker-entrypoint-initdb.d directory. Changes to either file will be available in the other.</p>\n<p>Run <em>docker-compose down --volumes</em> to ensure that nothing is left and start from a clean slate with <em>docker-compose up</em> to initialize the database.</p>\n<p>If you see an error like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mongo_database | failed to load: /docker-entrypoint-initdb.d/mongo-init.js\nmongo_database | exiting with code -3</code></pre></div>\n<p>you may have a read permission problem. They are not uncommon when dealing with volumes. In the above case, you can use <em>chmod a+r mongo-init.js</em>, which will give everyone read access to that file. Be careful when using chmod since granting more privileges can be a security issue. Use the chmod on the mongo-init.js on your computer, not inside the container.</p>\n<p>Now starting the express application with the correct environment variable should work:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ MONGO_URL=mongodb://the_username:the_password@localhost:3456/the_database npm run dev</code></pre></div>\n<p>Let's check that the <a href=\"http://localhost:8000/todos\">http://localhost:8000/todos</a> returns all todos. It should return the two todos we initialized. We can use postman to test the basic functionality for todos like delete todo.</p>\n<h4>Persisting data with volumes</h4>\n<p>By default containers are not going to persist our data. When you close the mongo container you may or may not be able to get the data back.</p>\n<p>This is a rare case in which it actually does preserve the data as the developers who made the docker image for Mongo have defined a volume to be used: <a href=\"https://github.com/docker-library/mongo/blob/cb8a419053858e510fc68ed2d69415b3e50011cb/4.4/Dockerfile#L113\">https://github.com/docker-library/mongo/blob/cb8a419053858e510fc68ed2d69415b3e50011cb/4.4/Dockerfile#L113</a> This line will instruct docker to preserve the data in those directories.</p>\n<p>There are two distinct methods to store the data: </p>\n<ol>\n<li>Declaring a location in your filesystem (called bind mount)</li>\n<li>Letting docker decide where to store the data (volume)</li>\n</ol>\n<p>I prefer the first choice in most cases whenever you really need to avoid deleting the data. Let's see both in action with docker-compose;</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> database\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js\n      <span class=\"token punctuation\">-</span> ./mongo_data<span class=\"token punctuation\">:</span>/data/db</code></pre></div>\n<p>The above will create a directory called <em>mongo</em>data_ to your local filesystem, and map it into the container as <em>/data/db</em>. This means the data in <em>/data/db</em> is stored outside of the container but still accessible by the container! Just remember to add the directory to .gitignore.</p>\n<p>Another great method is by using a named volume:</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> database\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js\n      <span class=\"token punctuation\">-</span> mongo_data<span class=\"token punctuation\">:</span>/data/db\n\n<span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n  mongo_data<span class=\"token punctuation\">:</span></code></pre></div>\n<p>Now the volume is created, but managed by docker. After starting the application (<em>docker-compose up</em>) you can list the volumes with <em>docker volume ls</em>, inspect one of them with <em>docker volume inspect</em> and even delete them with <em>docker volume rm</em>. It's still stored in your local filesystem but figuring out <i>where</i> may not be as trivial as with the previous option.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.7.</h3>\n<h4>Exercise 12.7: Little bit of mongodb coding</h4>\n<blockquote>\n<p>In this exercise, submit the entire express application, with the Dockerfile AND docker-compose.yml.</p>\n</blockquote>\n<p>The todo express application is missing both get one and update. </p>\n<p>Fix get one to return one todo with and id, and update to update one todo with an id.</p>\n</div>\n<div class=\"content\">\n<h3>Debugging issues in containers</h3>\n<blockquote>\n<p>When coding you most likely end up in a situation where everything is broken. </p>\n</blockquote>\n<blockquote>\n<p>- Matti Luukkainen</p>\n</blockquote>\n<p>We need to learn new tools for debugging. When code has a bug you may often be in a state where at least something works so you can work forward from that. Configuration most often is in either of the two states: 1. working or 2. broken. We'll go over a few tools to help when your application is in the latter state.</p>\n<p>The most difficult thing about this is that configuration is often broken when it's not finished. So when you write a long docker-compose.yml or Dockerfile and it does not work, you really need to take a moment and think about the various ways you could confirm something is working.</p>\n<p><i>Question Everything</i> is still applicable here. As said in part 3: The key is to be systematic. Since the problem can exist anywhere, <i>you must question everything</i>, and eliminate all possibilities one by one.</p>\n<p>For myself the most important method of debugging is stopping and really thinking about what I'm trying to accomplish instead of just bashing my head at the problem. Often there is a simple alternate solution or quick google search that will get me moving forward. </p>\n<h4>exec</h4>\n<p>The docker command <em>exec</em> is a heavy hitter. It can be used to jump right into a container when it's running. That's it.</p>\n<p>Let's start a web server, nginx, in the background and do a little bit of debugging to get it running and displaying the message \"Hello, exec!\" in our browser. Nginx is, among other things, a server capable of serving static html files. It has a default index.html that we can replace.</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ docker container run -d nginx</code></pre></div>\n<p>Ok, now where should we go with our browser? Is it even running? We know how to answer the latter.</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ docker container ls\nCONTAINER ID   IMAGE           COMMAND                  CREATED              STATUS                      PORTS     NAMES\n3f831a57b7cc   nginx           &quot;/docker-entrypoint.…&quot;   About a minute ago   Up About a minute           80/tcp    keen_darwin</code></pre></div>\n<p>Yes! It seems to listen on port 80, as output by the previous command.</p>\n<p>Let's shut it down and restart with the <em>-p</em> flag to have our browser access it.</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ docker container stop keen_darwin\n$ docker container rm keen_darwin\n\n$ docker container run -d -p 8080:80 nginx</code></pre></div>\n<p>Let's see the app in <a href=\"http://localhost:8080\">http://localhost:8080</a>. It seems the app is showing the wrong message! Let's hop right into the container and fix the message. Keep your browser open, we won't need to shut down the container for this fix. We will execute bash inside the container, the flags <em>-it</em> will ensure that we can interact with the container:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">$ docker container ls\nCONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                                   NAMES\n7edcb36aff08   nginx     &quot;/docker-entrypoint.…&quot;   About a minute ago   Up About a minute   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   wonderful_ramanujan\n\n$ docker exec -it wonderful_ramanujan bash\nroot@7edcb36aff08:/#</code></pre></div>\n<p>Now that we are in, we need to find the faulty file and replace it. Quick Google tells us that file itself is <em>/usr/share/nginx/html/index.html</em>.</p>\n<p>Let's move to the directory and delete the file</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">root@7edcb36aff08:/# cd /usr/share/nginx/html/\nroot@7edcb36aff08:/# rm index.html</code></pre></div>\n<p>Now if we go to <a href=\"http://localhost:8080/\">http://localhost:8080/</a> we know that we deleted the correct file. Let's replace it with one containing the correct contents:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">root@7edcb36aff08:/# echo &quot;Hello, exec!&quot; &gt; index.html</code></pre></div>\n<p>Refresh the page and our message is displayed!</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.8.</h3>\n<h4>Exercise 12.8: Mongo command-line interface</h4>\n<blockquote>\n<p>Use <em>script</em> to record what you do, save the generated file into the repository as your answer.</p>\n</blockquote>\n<p>While the mongodb from the previous exercise is running access the database with mongo command-line interface (cli) using docker exec and add a new todo using the cli.</p>\n<p>The command to open cli when inside the container is simply \"mongo\"</p>\n<p>The mongo cli will require the username and password flags to authenticate correctly. Flags <em>-u root -p example</em> should work, the values are from the docker-compose.yml.</p>\n<ul>\n<li>Step 1: Run mongodb</li>\n<li>Step 2: Use docker exec to get inside the container</li>\n<li>Step 3: Open mongo cli</li>\n</ul>\n<p>When you have connected to the mongo cli you can ask it to show dbs inside:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">&gt; show dbs\nadmin         0.000GB\nconfig         0.000GB\nlocal         0.000GB\nthe_database  0.000GB</code></pre></div>\n<p>To access the correct database:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">&gt; use the_database</code></pre></div>\n<p>And finally to find out the collections:</p>\n<div class=\"gatsby-highlight\" data-language=\"console\"><pre class=\"language-console\"><code class=\"language-console\">&gt; show collections\ntodos</code></pre></div>\n<p>We can now access the data in those collections:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&gt; db.todos.find({})\n{ &quot;_id&quot; : ObjectId(&quot;611e54b688ddbb7e84d3c46b&quot;), &quot;text&quot; : &quot;Write code&quot;, &quot;done&quot; : true }\n{ &quot;_id&quot; : ObjectId(&quot;611e54b688ddbb7e84d3c46c&quot;), &quot;text&quot; : &quot;Learn about containers&quot;, &quot;done&quot; : false }</code></pre></div>\n<p>Use the documentation <a href=\"https://docs.mongodb.com/v4.4/reference/method/db.collection.insertOne/#mongodb-method-db.collection.insertOne\">here</a> to insert one new todo with the text: \"Increase the number of tools in my toolbelt\" with status done as false!</p>\n</div>\n<div class=\"content\">\n<h3>Redis</h3>\n<p>Redis has nothing to do with containers. But since we are already able to add <i>any</i> 3rd party service to your applications, why not learn about a new one.</p>\n<p>Redis is a data store. So just like mongo it can be used to store data. The difference is that Redis stores key-value data. And it is by default in-memory which means that it does not store data persistently.</p>\n<p>An excellent use case for Redis is to use it as a cache. Caches are often used to store data that is otherwise slow to fetch, and save it until it's no longer valid and then fetch the data and store it to the cache.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercises 12.9. - 12.11.</h3>\n<h4>Exercise 12.9: Setup redis to project</h4>\n<blockquote>\n<p>In this exercise, submit the entire express application, with the Dockerfile AND docker-compose.yml.</p>\n</blockquote>\n<p>The application will be able to use redis by giving it the <em>REDIS_URL</em> environment variable. Find and read through the <a href=\"https://hub.docker.com/_/redis\">Docker Hub page for redis</a>, add it to the docker-compose.yml by defining another service after mongo:</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">...</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">?</span><span class=\"token punctuation\">?</span><span class=\"token punctuation\">?</span></code></pre></div>\n<p>Since the Docker Hub page doesn't have all info we can use Google to aid us. The default port for redis is found by doing so:</p>\n<picture><img src=\"/static/c2052870c4d9cd9369bf0f66dd1b1cf9/5a190/redis_port_by_google.png\" srcset=\"/static/c2052870c4d9cd9369bf0f66dd1b1cf9/772e8/redis_port_by_google.png 200w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/e17e5/redis_port_by_google.png 400w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/5a190/redis_port_by_google.png 800w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/f96df/redis_port_by_google.png 849w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>We won't have any idea if the configuration works unless we try it. The application will not start using redis by itself. You will need to require the config by adding something along the lines of</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> redis <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../redis'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>to the express server. You may also move to the next exercise, the next exercise will require redis to be available and configured correctly.</p>\n<h4>Exercise 12.10:</h4>\n<blockquote>\n<p>In this exercise, submit the entire express application, with the Dockerfile AND docker-compose.yml.</p>\n</blockquote>\n<p>The project already has <a href=\"https://www.npmjs.com/package/redis\">https://www.npmjs.com/package/redis</a> installed and two functions \"promisified\" - getAsync and setAsync.</p>\n<ul>\n<li>setAsync function takes in key and value, using the key to store the value.</li>\n<li>getAsync function takes in key and returns the value in a promise.</li>\n</ul>\n<p>Implement a todo counter:</p>\n<ul>\n<li>Step 1: Whenever a request is sent to add a todo, increment the counter by one.</li>\n<li>Step 2: Create a GET /statistics endpoint where you can ask the usage metadata. The format should be the following JSON:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  added_todos<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>Exercise 12.11:</h4>\n<blockquote>\n<p>Use <em>script</em> to record what you do, save the generated file into the repository as your answer.</p>\n</blockquote>\n<p>Like we did with mongo we can do with redis. Use redis command-line interface to edit the value in the database. </p>\n<p>The command to open the redis cli is \"redis-cli\".</p>\n<p>You can find the key you used with <em><a href=\"https://redis.io/commands/keys\">KEYS *</a></em></p>\n<p>And set the value with <em><a href=\"https://redis.io/commands/set\">SET</a></em>, giving it the key and then the value</p>\n<p>And finally set the value of the counter to 9001.</p>\n<p>Make sure that the new value works by using your application. Refresh the application and see that it has the new number, and the redis cli shows new number when asking with <em><a href=\"https://redis.io/commands/get\">GET</a></em>, giving it the key</p>\n</div>\n<div class=\"content\">\n<h4>Persisting data with Redis</h4>\n<p>In the previous section I said that <i>by default</i> Redis does not persist the data. However, the persistence is easy to toggle on. We will only need to start the redis with a different command, as instructed by the docker hub page:</p>\n<p><code class=\"language-text\">docker-compose.yml</code></p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># Everything else</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'redis-server'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'--appendonly'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'yes'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># Overwrite the CMD</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># Declare the volume</span>\n      <span class=\"token punctuation\">-</span> ./redis_data<span class=\"token punctuation\">:</span>/data</code></pre></div>\n<p>Remember to add the directory to .gitignore.</p>\n<h4>Other functionality Redis has</h4>\n<p>In addition to the most basic get &#x26; set Redis can automatically expire keys. And manage multiple key value pairs at the same time.</p>\n<p>In addition to the key-value features Redis can also be used to Publish messages and Subscribe to messages (PubSub or Publish-subscribe pattern). Publish-subscribe is great for having multiple applications communicate with each other. Redis works as the message broker between two or more applications, where one of them is publishing messages by sending them to redis, and the other is subscribed to those messages.</p>\n</div>\n<div class=\"tasks\">\n<h3>Exercise 12.12.</h3>\n<h4>Exercise 12.12: Persisting data in redis</h4>\n<blockquote>\n<p>In this exercise, submit the entire express application, with the Dockerfile AND docker-compose.yml.</p>\n</blockquote>\n<p>Check that the data is not persisted by default: after running <em>docker-compose down</em> and <em>docker-compose up</em> the counter value is reset to 0.</p>\n<p>Then create a volume for redis data and make sure that the data survives after running <em>docker-compose down</em> and <em>docker-compose up</em>.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/3c94fa433f40d6b2797b2e0c31a5cba3/part-12.svg"},"part":12,"letter":"b","lang":"en"}}},"pageContext":{"part":12,"letter":"b","lang":"en"}}}